function parseCommentBlock(cont, lines, start, end) {
	var commentLines = lines.slice(start - 1, end);
	var unparsedComment = commentLines;

	var descr = [];
	for (var line = 0; line < unparsedComment.length;) {
		if (unparsedComment[i].trim() === '*') {
			unparsedComment.splice(i, 1);
			break;
		} else {
			descr.push(unparsedComment.splice(i,1).trim().replace('*', '').trim());
		}
	}

	descr = descr.join(' ');

	var isFn = true;
	var propertyProps = {
		'!doc': descr
	}

	var fnProps = {
		'!doc': descr
	}

	//TODO implement the typedefs
	var currentProp;
	var currentValue;
	for (var i = 0; i < unparsedComment.length; i++) {
		var line = unparsedComment[i].replace('*', '').trim();
		if (line.indexOf('@') === 0) {
			if (line.indexOf('@type') === 0) {
				isFn = false;
				propertyProps.type = line.split('@type')[1].trim();
				switch (propertyProps.type.toLowerCase()) {
					case 'boolean':
					case 'bool':
						propertyProps.type = 'bool';
						break;
					case 'object':
						propertyProps.type = undefined;
						break;
				}
			} else if (line.indexOf('@param') === 0 || line.indexOf('@returns') === 0) {
				var type = line.match(/{(\w)+}/)[1];

				var lineSplit = line.split(type).slice(1).join(type);

				if (type === 'boolean') {
					type = 'bool';
				} else if (type === 'object') {
					//TODO
					type = '?';
				}
				type = type.toLocaleLowerCase();

				var isParam = line.indexOf('@param') === 0;

				if (isParam) {
					var param = lineSplit[1].trim().match(/[\w|\[|\|.|0-9]]+/)[0];
					if (param.indexOf('.') > -1) {
						//It's a sub-property, ignore
						continue;
					}
				}

				currentValue = [lineSplit[1].split('-')[1]];

				currentProp = {
					type: type,
					param: param,
					isParam: isParam
				};

			}
		} else {
			currentValue.push(line);

			var descr = currentValue.join(' ');
			if (currentProp.isParam) {
				fnProps.params = fnProps.params || [];
				fnProps.params.push({
					type: currentProp.type,
					descr: descr
				});
			} else {
				fnProps.returns = {
					type: currentProp.type,
					paramName: currentProp.param,
					descr: descr
				};
			}
		}
	}

	//TODO rework crmAPI to include object props in description
	if (isFn) {

	} else {
		cont['!type'] = propertyProps.type;
		cont['!doc'] = propertyProps['!doc'];
	}
}

function extractDefsFromLine(defs, lines, lineNumber) {
	var line = lines[lineNumber].slice(1);

	var definition = line.match(/this.([a-z|A-Z|0-9|\.]+)]/)[1];
	var definitionSplit = definition.split('.');

	var cont = defs;
	for (var i = 0; i < definitionSplit.length - 1; i++) {
		if (cont[definitionSplit[i]]) {
			cont = cont[definitionSplit[i]];
		} else {
			cont[definitionSplit[i]] = {};
		}
	}

	//Get the comment block
	var commentBlockStart = -1;
	var commentBlockEnd = lineNumber - 1;

	var currentLine = lineNumber;
	commentBlockEnd = lineNumber - 1;
	for (; currentLine.indexOf('/**') === -1; currentLine--) { }
	commentBlockStart = lineNumber;

	var comment = parseCommentBlock(cont, lines, commentBlockStart, commentBlockEnd);
}

function extractDefs(js) {
	var defs = {};
	
	var lines = js.split('\n');
	var propRegex = new RegExp(/(\s)this.(\w+)/);
	for (var i = 0; i < lines.length; i++) {
		var match = lines[i].match(propRegex);
		if (match && lines[i].indexOf(match[0]) === 0) {
			extractDefsFromLine(defs, lines, i);
		}
	}

	return {
		"!name": "crmAPI",
		"crmAPI": defs
	};
}

function joinSplitJs(splitJs) {
	return splitJs.join('\n');
}

(function() {
	extractDefs(["///<reference path=\"eo.js\"/>", "/** ", " * A class for constructing the CRM API", " * ", " * @class", " * @param {Object} node - The item currently being edited", " * @param {number} id - The id of the current item", " * @param {number} tabData - Any data about the tab the script is currently running on", " * @param {Object} clickData - Any data associated with clicking this item in the", " *\t\tcontext menu, only available if launchMode is equal to 0 (on click)", " * @param {number[]} secretyKey - An array of integers, generated to keep downloaded ", " *\t\tscripts from finding local scripts with more privilege and act as if they ", " *\t\tare those scripts to run stuff you don't want it to.", " * @param {Object} nodeStorage - The storage data for the node", " * @param {Object} greasemonkeyData - Any greasemonkey data, including metadata", " */", "function CrmAPIInit(node, id, tabData, clickData, secretKey, nodeStorage, greasemonkeyData) {", "", "\tvar _this = this;", "", "\t//#region Options", "\t//If true, outputs stacktraces to the page the script is run on, true by default.", "\tthis.stackTraces = true;", "", "\t//If true, throws an error when one of your crmAPI calls is incorrect (such as a type mismatch or any other fail). True by default.", "\tthis.errors = true;", "\t//#endregion", "", "\t//#region JSONfn", "\t/**", "\t* JSONfn - javascript (both node.js and browser) plugin to stringify, ", "\t*          parse and clone objects with Functions, Regexp and Date.", "\t*  ", "\t* Version - 0.60.00", "\t* Copyright (c) 2012 - 2014 Vadim Kiryukhin", "\t* vkiryukhin @ gmail.com", "\t* http://www.eslinstructor.net/jsonfn/", "\t* ", "\t* Licensed under the MIT license ( http://www.opensource.org/licenses/mit-license.php )", "\t*/", "\tvar jsonFn = {", "\t\tstringify: function(obj) {", "\t\t\treturn JSON.stringify(obj, function(key, value) {", "\t\t\t\tif (value instanceof Function || typeof value == 'function') {", "\t\t\t\t\treturn value.toString();", "\t\t\t\t}", "\t\t\t\tif (value instanceof RegExp) {", "\t\t\t\t\treturn '_PxEgEr_' + value;", "\t\t\t\t}", "\t\t\t\treturn value;", "\t\t\t});", "\t\t},", "\t\tparse: function (str, date2Obj) {", "\t\t\tvar iso8061 = date2Obj ? /^(\\d{4})-(\\d{2})-(\\d{2})T(\\d{2}):(\\d{2}):(\\d{2}(?:\\.\\d*)?)Z$/ : false;", "\t\t\treturn JSON.parse(str, function (key, value) {", "\t\t\t\tif (typeof value != 'string') {", "\t\t\t\t\treturn value;", "\t\t\t\t}", "\t\t\t\tif (value.length < 8) {", "\t\t\t\t\treturn value;", "\t\t\t\t}", "", "\t\t\t\tvar prefix = value.substring(0, 8);", "", "\t\t\t\tif (iso8061 && value.match(iso8061)) {", "\t\t\t\t\treturn new Date(value);", "\t\t\t\t}", "\t\t\t\tif (prefix === 'function') {", "\t\t\t\t\treturn eval('(' + value + ')');", "\t\t\t\t}", "\t\t\t\tif (prefix === '_PxEgEr_') {", "\t\t\t\t\treturn eval(value.slice(8));", "\t\t\t\t}", "", "\t\t\t\treturn value;", "\t\t\t});", "\t\t}", "\t};", "\t//#endregion", "", "\t//#region Properties of this Object", "\tObject.defineProperty(this, 'tabId', {", "\t\tget: function() {", "\t\t\treturn tabData.id;", "\t\t}", "\t});", "\tObject.defineProperty(this, 'permissions', {", "\t\tget: function() {", "\t\t\treturn node.permissions;", "\t\t}", "\t});", "\t//#endregion", "", "\t//#region Communication", "\tvar callInfo = {};", "", "\tfunction getStackTrace(error) {", "\t\treturn error.stack.split('\\n');", "\t}", "", "\tfunction createDeleterFunction(index) {", "\t\treturn function() {", "\t\t\tdelete callInfo[index];", "\t\t}", "\t}", "", "\t/**", "\t * Creates a callback function that gets executed here instead of in the background page", "\t * ", "\t * @param {function} callback - A handler for the callback function that gets passed", "\t *\t\tthe status of the call (error or succes), some data (error message or function params)", "\t *\t\tand a stacktrace.", "\t * @param {Error} error - The \"new Error\" value to formulate a useful stack trace", "\t * @param {Boolean} [persistent] - If this value is true the callback will not be deleted", "\t *\t\teven after it has been called", "\t * @returns {number} - The value to use as a callback function", "\t */", "\tfunction createCallback(callback, error, persistent) {", "\t\terror = error || new Error;", "\t\tvar index = 0;", "\t\twhile (callInfo[index]) {", "\t\t\tindex++;", "\t\t}", "\t\tcallInfo[index] = {", "\t\t\tcallback: callback,", "\t\t\tstackTrace: _this.stackTraces && getStackTrace(error),", "\t\t\tpersistent: persistent", "\t\t};", "\t\t//Wait an hour for the extreme cases, an array with a few numbers in it can't be that horrible", "\t\tif (!persistent) {", "\t\t\tsetTimeout(createDeleterFunction(index), 3600000);", "\t\t}", "", "\t\t// ReSharper disable UseOfImplicitGlobalInFunctionScope", "\t\tvar fn = function () {", "\t\t\tvar callbackId = CBID;", "\t\t\tvar nodeId = NODEID;", "\t\t\tvar tabId = TABID;", "\t\t\tvar err = chrome.runtime.lastError;", "\t\t\twindow.sendCallbackMessage.apply(this, {", "\t\t\t\tsuccess: !err,", "\t\t\t\terror: !!err,", "\t\t\t\terrorMessage: err && err.message,", "\t\t\t\tcallbackId: callbackId,", "\t\t\t\targs: Array.from(arguments),", "\t\t\t\ttabId: tabId,", "\t\t\t\tid: nodeId", "\t\t\t});", "\t\t}", "\t\t// ReSharper restore UseOfImplicitGlobalInFunctionScope", "", "\t\t//Replace the template values with the real values", "\t\tvar stringifiedFn = jsonFn.stringify(fn);", "\t\tstringifiedFn.replace(/CBID/, index);", "\t\tstringifiedFn.replace(/TABID/, tabData.id);", "\t\tstringifiedFn.replace(/NODEID/, id);", "\t\treturn jsonFn.parse(stringifiedFn);", "\t}", "", "\t/**", "\t * Creates a callback function that gets executed here instead of in the background page", "\t * ", "\t * @param {function} callback - The function to run", "\t * @param {Error} error - The \"new Error\" value to formulate a useful stack trace", "\t * @param {Boolean} [persistent] - If this value is true the callback will not be deleted", "\t *\t\teven after it has been called", "\t * @returns {number} - The value to use as a callback function", "\t */", "\tfunction createCallbackFunction(callback, error, persistent) {", "\t\tfunction onFinish(status, messageOrParams, stackTrace) {", "\t\t\tif (status === 'error') {", "\t\t\t\t_this.onError && _this.onError(messageOrParams);", "\t\t\t\tif (_this.stackTraces) {", "\t\t\t\t\tsetTimeout(function () {", "\t\t\t\t\t\tconsole.log('stack trace: ');", "\t\t\t\t\t\tstackTrace.forEach(function (line) {", "\t\t\t\t\t\t\tconsole.log(line);", "\t\t\t\t\t\t});", "\t\t\t\t\t}, 5);", "\t\t\t\t}", "\t\t\t\tif (_this.errors) {", "\t\t\t\t\tthrow new Error('CrmAPIError: ' + messageOrParams.error);", "\t\t\t\t} else {", "\t\t\t\t\tconsole.warn('CrmAPIError: ' + messageOrParams.error);", "\t\t\t\t}", "\t\t\t} else {", "\t\t\t\tcallback.apply(_this, messageOrParams);", "\t\t\t}", "\t\t}", "", "\t\tcreateCallback(onFinish, error, persistent);", "\t}", "", "\t//Connect to the background-page", "\tvar queue = [];", "\tvar sendMessage = function(message) {", "\t\tqueue.push(message);", "\t}", "\tvar port = chrome.runtime.connect({", "\t\tname: JSON.stringify(secretKey)", "\t});", "", "", "\tfunction handshakeFunction() {", "\t\tsendMessage = function(message) {", "\t\t\tif (message.onFinish) {", "\t\t\t\tmessage.onFinish = createCallback(message.onFinish, new Error);", "\t\t\t}", "\t\t\tport.postMessage(message);", "\t\t};", "", "\t\tqueue.forEach(function(message) {", "\t\t\tsendMessage(message);", "\t\t});", "\t\tqueue = null;", "\t}", "", "\tfunction callbackHandler(message) {", "\t\tcallInfo[message.callbackId].callback(message.type, message.data, callInfo[message.callbackId].stackTrace);", "\t\tif (!callInfo[message.callbackId].persistent) {", "\t\t\tdelete callInfo[message.callbackId];", "\t\t}", "\t}", "", "\tvar instances = [];", "", "\tfunction messageHandler(message) {", "\t\tif (queue) { //Message queue is not empty", "\t\t\t//Update instance array", "\t\t\tinstances = message.instances;", "\t\t\tfor (var i = 0; i < instances.length; i++) {", "\t\t\t\tinstances[i] = {", "\t\t\t\t\tid: instances[i],", "\t\t\t\t\tsendMessage: generateSendInstanceMessageFunction(instances[i])", "\t\t\t\t};", "\t\t\t}", "\t\t\thandshakeFunction();", "\t\t} else {", "\t\t\tswitch (message.messageType) {", "\t\t\t\tcase 'callback':", "\t\t\t\t\tcallbackHandler(message);", "\t\t\t\t\tbreak;", "\t\t\t\tcase 'storageUpdate':", "\t\t\t\t\tremoteStorageChange(message.changes);", "\t\t\t\t\tbreak;", "\t\t\t\tcase 'instancesUpdate':", "\t\t\t\t\tinstancesChange(message.change);", "\t\t\t\t\tbreak;", "\t\t\t\tcase 'instanceMessage':", "\t\t\t\t\tinstanceMessageHandler(message);", "\t\t\t\t\tbreak;", "\t\t\t}", "\t\t}", "\t}", "", "\tport.onMessage.addListener(messageHandler);", "\tport.postMessage({", "\t\tid: id,", "\t\tkey: secretKey,", "\t\ttabId: _this.tabId", "\t});", "", "\t//#endregion", "", "\t//#region Helper functions", "\tfunction emptyFn() {}", "", "\t/**", "\t * Checks whether value matches given type and is defined and not null,", "\t *\tthird parameter can be either a string in which case it will be", "\t *\tmentioned in the error message, or it can be a boolean which if", "\t *\ttrue will prevent an error message and instead just returns a", "\t *\tsuccess or no success boolean.", "\t * ", "\t * @param {*} value The value to check", "\t * @param {string} type - The type that the value should be", "\t * @param {string|boolean} nameOrMode If a string, the name of the value to check (shown in error message),", "\t * if a boolean and true, turns on non-error-mode", "\t * @returns {boolean} Whether the type matches ", "\t */", "\tfunction checkType(value, type, nameOrMode) {", "\t\t(type.splice || (type = [type]));", "\t\tif (typeof nameOrMode === 'boolean' && nameOrMode) {", "\t\t\treturn (value !== undefined && value !== null && ((type.indexOf(typeof value) > -1 && !value.splice) || (type.indexOf('array') > -1 && typeof value === 'object' && value.splice)));", "\t\t}", "\t\tif (value === undefined || value === null) {", "\t\t\tthrow new Error('Value ' + (nameOrMode ? 'of ' + nameOrMode : '') + 'is undefined or null');", "\t\t}", "\t\tif (!((type.indexOf(typeof value) > -1 && !value.splice) || (type.indexOf('array') > -1 && typeof value === 'object' && value.splice))) {", "\t\t\tthrow new Error('Value ' + (nameOrMode ? 'of ' + nameOrMode : '') + ' is not of type' + ((type.length > 1) ? 's ' + type.join(', ') : ' ' + type));", "\t\t}", "\t\treturn true;", "\t}", "", "\t/**", "\t * Looks up the data at given path", "\t * ", "\t * @param {array} path - The path at which to look", "\t * @param {Object} data - The data to look at", "\t * @param {boolean} hold - Whether to return the second-to-last instead of the last data", "\t * @returns {*} The found value", "\t */", "\tfunction lookup(path, data, hold) {", "\t\tcheckType(path, 'array', 'path');", "\t\tcheckType(data, 'Object', 'data');", "\t\tvar length = path.length;", "\t\thold && length--;", "\t\tfor (var i = 0; i < length; i++) {", "\t\t\tdata = data[path[i]];", "\t\t}", "\t\treturn data;", "\t}", "", "\t/**", "\t * Merges two objects where the main object is overwritten", "\t * ", "\t * @param {Object} mainObject - The object to merge it INTO ", "\t * @param {Object} additions - The object to merge INTO IT", "\t * @returns {Object} The merged object", "\t */", "\tfunction mergeObjects(mainObject, additions) {", "\t\tfor (var key in additions) {", "\t\t\tif (additions.hasOwnProperty(key)) {", "\t\t\t\tif (typeof additions[key] === 'object') {", "\t\t\t\t\tmergeObjects(mainObject[key], additions[key]);", "\t\t\t\t} else {", "\t\t\t\t\tmainObject[key] = additions[key];", "\t\t\t\t}", "\t\t\t}", "\t\t}", "\t\treturn mainObject;", "\t}", "", "\t/**", "\t * Returns the function if the function was actually a function and exists", "\t * returns an empty function if it's not", "\t * ", "\t * @param {function} fn - The function to check", "\t * @returns {function} The actual function or an empty one depending on the outcome", "\t */", "\tfunction isFn(fn) {", "\t\tif (fn && typeof fn === 'function') {", "\t\t\treturn fn;", "\t\t}", "\t\treturn emptyFn;", "\t}", "", "\t//#endregion", "", "\t//#region Instance Communication", "\tthis.comm = {};", "\tvar commListeners = [];", "", "\tfunction instancesChange(change) {", "\t\tswitch (change.type) {", "\t\t\tcase 'removed':", "\t\t\t\tfor (var i = 0; i < instances.length; i++) {", "\t\t\t\t\tif (instances[i] === change.value) {", "\t\t\t\t\t\tinstances.splice(i, 1);", "\t\t\t\t\t\tbreak;", "\t\t\t\t\t}", "\t\t\t\t}", "\t\t\t\tbreak;", "\t\t\tcase 'added':", "\t\t\t\tinstances.push({", "\t\t\t\t\tid: value,", "\t\t\t\t\tsendMessage: generateSendInstanceMessageFunction(value)", "\t\t\t\t});", "\t\t\t\tbreak;", "\t\t}", "\t}", "", "\tfunction instanceMessageHandler(message) {", "\t\tcommListeners.forEach(function(listener) {", "\t\t\tlistener && typeof listener === 'function' && listener(message.message);", "\t\t});", "\t}", "", "\tfunction generateSendInstanceMessageFunction(instanceId) {", "\t\treturn function(message, callback) {", "\t\t\tsendInstanceMessage(instanceId, message, callback);", "\t\t}", "\t}", "", "\tfunction sendInstanceMessage(instanceId, message, callback) {", "\t\tfunction onFinish(type, data) {", "\t\t\tif (type === 'error') {", "\t\t\t\tcallback({", "\t\t\t\t\terror: true,", "\t\t\t\t\tsuccess: false,", "\t\t\t\t\tmessage: data", "\t\t\t\t});", "\t\t\t} else {", "\t\t\t\tcallback({", "\t\t\t\t\terror: false,", "\t\t\t\t\tsuccess: true", "\t\t\t\t});", "\t\t\t}", "\t\t}", "", "\t\tsendMessage({", "\t\t\tid: id,", "\t\t\ttype: 'sendInstanceMessage',", "\t\t\tdata: {", "\t\t\t\ttoInstanceId: instanceId,", "\t\t\t\tmessage: message,", "\t\t\t\tid: id,", "\t\t\t\ttabId: _this.tabId", "\t\t\t},", "\t\t\ttabId: _this.tabId,", "\t\t\tonFinish: onFinish", "\t\t});", "\t}", "", "\tfunction updateCommHandlerStatus(hasHandler) {", "\t\tsendMessage({", "\t\t\tid: id,", "\t\t\ttype: 'changeInstanceHandlerStatus',", "\t\t\tdata: {", "\t\t\t\thasHandler: hasHandler", "\t\t\t},", "\t\t\ttabId: _this.tabId,", "\t\t\tonFinish: onFinish", "\t\t});", "\t}", "", "\t/*", "\t * Returns all instances running in other tabs, these instances can be passed", "\t * to the .comm.sendMessage function to send a message to them, you can also", "\t * call instance.sendMessage on them", "\t */", "\tthis.comm.getInstances = function() {", "\t\treturn instances;", "\t}", "", "\t/**", "\t * Sends a message to given instance", "\t * ", "\t * @param {instance} instance - The instance to send the message to", "\t * @param {Object} message - The message to send", "\t * @param {function} callback - A callback that tells you the result,", "\t *\t\tgets passed one argument (object) that contains the two boolean", "\t *\t\tvalues \"error\" and \"success\" indicating whether the message", "\t *\t\tsucceeded. If it did not succeed and an error occurred,", "\t *\t\tthe message key of that object will be filled with the reason", "\t *\t\tit failed (\"instance no longer exists\" or \"no listener exists\")", "\t */", "\tthis.comm.sendMessage = function (instance, message, callback) {", "\t\tisFn(instance.sendMessage)(message, callback);", "\t}", "", "\t/**", "\t * Adds a listener for any comm-messages sent from other instances of", "\t * this script", "\t * ", "\t * @param {function} listener - The listener that gets called with the message", "\t */", "\tthis.comm.addListener = function(listener) {", "\t\tcommListeners.push(listener);", "\t\tif (commListeners.length === 1) {", "\t\t\tupdateCommHandlerStatus(true);", "\t\t}", "\t}", "", "\tthis.comm.removeListener = function(listener) {", "\t\tcommListeners.splice(commListeners.indexOf(listener), 1);", "\t\tif (commListeners.length === 0) {", "\t\t\tupdateCommHandlerStatus(false);", "\t\t}", "\t}", "\t//#endregion", "", "\t//#region Storage", "\tvar storage = nodeStorage;", "", "\tthis.storage = {};", "", "\tvar storageListeners = [];", "\tvar storageIndexGM = 0;", "\tvar storageListenersGM = {};", "\tvar storagePrevious = {};", "", "\t/*", "\t * Notifies any listeners of changes to the storage object", "\t */", "\tfunction notifyChanges(keyPath, oldValue, newValue, remote) {", "\t\tfor (var listenerObj in storageListenersGM) {", "\t\t\tif (storageListenersGM.hasOwnProperty(listenerObj)) {", "\t\t\t\tif (listenerObj.key.indexOf(keyPath) > -1) {", "\t\t\t\t\tisFn(listenerObj.callback)(listenerObj.key, oldValue, newValue, remote);", "\t\t\t\t}", "\t\t\t}", "\t\t}", "\t\tstoragePrevious = nodeStorage;", "\t}", "", "\tfunction remoteStorageChange(changes) {", "\t\tfor (var i = 0; i < changes.length; i++) {", "\t\t\tnotifyChanges(changes[i].keyPath, changes[i].oldValue, changes[i].newValue, true);", "", "\t\t\tvar data = lookup(changes[i].keyPath, nodeStorage, true);", "\t\t\tdata[changes[i].keyPath[changes[i].keyPath.length - 1]] = changes[i].newValue;", "\t\t\tstoragePrevious = nodeStorage;", "\t\t}", "\t}", "", "\tfunction localStorageChange(keyPath, oldValue, newValue) {", "\t\tsendMessage({", "\t\t\tid: id,", "\t\t\ttype: 'updateStorage',", "\t\t\tdata: {", "\t\t\t\ttype: 'nodeStorage',", "\t\t\t\tnodeStorageChanges: [", "\t\t\t\t\t{", "\t\t\t\t\t\tkey: keyPath,", "\t\t\t\t\t\toldValue: oldValue,", "\t\t\t\t\t\tnewValue: newValue", "\t\t\t\t\t}", "\t\t\t\t],", "\t\t\t\tid: id,", "\t\t\t\ttabId: _this.tabId", "\t\t\t},", "\t\t\ttabId: _this.tabId", "\t\t});", "\t\tnotifyChanges(keyPath, oldValue, newValue, false);", "\t}", "", "\tstorage = storage || {};", "", "\t/**", "\t * Gets the value at given key, if no key is given returns the entire storage object", "\t * ", "\t * @param {string|array} [keyPath] - The path at which to look, can be either", "\t *\t\ta string with dots seperating the path, an array with each entry holding", "\t *\t\tone section of the path, or just a plain string without dots as the key,", "\t *\t\tcan also hold nothing to return the entire storage", "\t * @returns {any} The data you are looking for", "\t */", "\tthis.storage.get = function (keyPath) {", "\t\tif (!keyPath) {", "\t\t\treturn storage;", "\t\t}", "\t\tif (checkType(keyPath, 'string', true)) {", "\t\t\tif (keyPath.indexOf('.') === -1) {", "\t\t\t\treturn storage[keyPath];", "\t\t\t} else {", "\t\t\t\tkeyPath = keyPath.split('.');", "\t\t\t}", "\t\t}", "\t\tcheckType(keyPath, 'array', 'keyPath');", "\t\treturn lookup(keyPath, storage);", "\t};", "", "\t/**", "\t * Sets the data at given key to given value", "\t * ", "\t * @param {string|array} keyPath - The path at which to look, can be either", "\t *\t\ta string with dots seperating the path, an array with each entry holding", "\t *\t\tone section of the path, or just a plain string without dots as the key", "\t * @param {any} value - The value to set it to", "\t */", "\tthis.storage.set = function (keyPath, value) {", "\t\tif (checkType(keyPath, 'string', true)) {", "\t\t\tif (keyPath.indexOf('.') === -1) {", "\t\t\t\tlocalStorageChange(keyPath, nodeStorage[keyPath], value);", "\t\t\t\tnodeStorage[keyPath] = value;", "\t\t\t\tstoragePrevious = nodeStorage;", "\t\t\t\treturn undefined;", "\t\t\t} else {", "\t\t\t\tkeyPath = keyPath.split('.');", "\t\t\t}", "\t\t}", "\t\tif (checkType(keyPath, 'array', true)) {", "\t\t\tvar data = lookup(keyPath, nodeStorage, true);", "\t\t\tlocalStorageChange(keyPath, data[keyPath[keyPath.length - 1]], value);", "\t\t\tdata[keyPath[keyPath.length - 1]] = value;", "\t\t\tstoragePrevious = nodeStorage;", "\t\t\treturn undefined;", "\t\t}", "\t\tcheckType(keyPath, ['string', 'array', 'object'], 'keyPath');", "\t\tfor (var key in keyPath) {", "\t\t\tif (keyPath.hasOwnProperty(key)) {", "\t\t\t\tlocalStorageChange(keyPath, nodeStorage[key], value);", "\t\t\t\tnodeStorage[key] = value;", "\t\t\t}", "\t\t}", "\t\tstoragePrevious = nodeStorage;", "\t\treturn undefined;", "\t};", "", "\t/**", "\t * Deletes the data at given key given value", "\t * ", "\t * @param {string|array} keyPath The path at which to look, can be either", "\t *\t\ta string with dots seperating the path, an array with each entry holding", "\t *\t\tone section of the path, or just a plain string without dots as the key", "\t */", "\tthis.storage.remove = function (keyPath) {", "\t\tif (checkType(keyPath, 'string', true)) {", "\t\t\tif (keyPath.indexOf('.') === -1) {", "\t\t\t\tnotifyChanges(keyPath, nodeStorage[keyPath], undefined);", "\t\t\t\tdelete nodeStorage[keyPath];", "\t\t\t\tstoragePrevious = nodeStorage;", "\t\t\t\treturn undefined;", "\t\t\t} else {", "\t\t\t\tkeyPath = keyPath.split('.');", "\t\t\t}", "\t\t}", "\t\tif (checkType(keyPath, 'array', true)) {", "\t\t\tvar data = lookup(keyPath, nodeStorage, true);", "\t\t\tnotifyChanges(keyPath, data[keyPath[keyPath.length - 1]], undefined);", "\t\t\tdelete data[keyPath[keyPath.length - 1]];", "\t\t\tstoragePrevious = nodeStorage;", "\t\t\treturn undefined;", "\t\t}", "\t\tcheckType(keyPath, ['string', 'array', 'object'], 'keyPath');", "\t\tfor (var key in keyPath) {", "\t\t\tif (keyPath.hasOwnProperty(key)) {", "\t\t\t\tnotifyChanges(keyPath, nodeStorage[key], undefined);", "\t\t\t\tdelete nodeStorage[key];", "\t\t\t}", "\t\t}", "\t\tstoragePrevious = nodeStorage;", "\t\treturn undefined;", "\t};", "", "\tthis.storage.onChange = {};", "\t/**", "\t * Adds an onchange listener for the storage, listens for a key if given", "\t * ", "\t * @param {function} listener - The function to run, gets called ", "\t *\t\tgets called with the first argument being the key, the second being", "\t *\t\tthe old value, the third being the new value and the fourth", "\t *\t\ta boolean indicating if the change was on a remote tab", "\t * @param {string} [key] - The key to listen for", "\t */", "\tthis.storage.onChange.addListener = function (listener, key) {", "\t\tstorageListeners.push({", "\t\t\tlistener: listener,", "\t\t\tkey: key", "\t\t});", "\t};", "", "\t/**", "\t * Removes ALL listeners with given listener (function) as the listener,", "\t *\tif key is given also checks that they have that key", "\t * ", "\t * @param {function} listener - The listener to remove", "\t * @param {string} [key] - The key to check ", "\t */", "\tthis.storage.onChange.removeListener = function (listener, key) {", "\t\tvar indexes = [];", "\t\tvar i;", "\t\tfor (i = 0; i < storageListeners.length; i++) {", "\t\t\tif (storageListeners[i].listener === listener) {", "\t\t\t\tif (key !== undefined) {", "\t\t\t\t\tif (storageListeners[i].key === key) {", "\t\t\t\t\t\tindexes.push(i);", "\t\t\t\t\t}", "\t\t\t\t} else {", "\t\t\t\t\tindexes.push(i);", "\t\t\t\t}", "\t\t\t}", "\t\t}", "\t\tfor (i = 0; i < indexes.length; i++) {", "\t\t\tstorageListeners.splice(indexes[i], 1);", "\t\t}", "\t}", "\t//#endregion", "", "\t//#region PageAPI", "\t/*", "\t * Gets the current text selection", "\t */", "\tthis.getSelection = function () {", "\t\treturn clickData.selectionText || window.getSelection().toString();", "\t}", "", "\t/*", "\t * All of the remaining functions in this region below this message will only work if your", "\t * script runs on clicking, not if your script runs automatically, in that case you will always", "\t * get undefined (except for the function above). For more info check out this page's onclick ", "\t * section (https://developer.chrome.com/extensions/contextMenus#method-create)", "\t */", "", "\t/**", "\t * Returns any data about the click on the page (https://developer.chrome.com/extensions/contextMenus#method-create)", "\t *\t\tfor more info of what can be returned.", "\t * ", "\t * @returns {object} An object containing any info about the page, some data may be undefined if it doesn't apply ", "\t */", "\tthis.getClickInfo = function () {", "\t\treturn clickData;", "\t}", "", "\t/**", "\t * Gets any info about the current tab/window", "\t * ", "\t * @returns {Object} - An object of type tab (https://developer.chrome.com/extensions/tabs#type-Tab)", "\t */", "\tthis.getTabInfo = function () {", "\t\treturn tabData;", "\t}", "", "\t/**", "\t * Gets the current node", "\t * ", "\t * @returns {Object} - The node that is being executed right now", "\t */", "\tthis.getNode = function () {", "\t\treturn node;", "\t}", "", "\t//#endregion", "", "\t//#region Changes in CRM", "\t//The CRM's data is limited to some degree, data that might let you access other scripts or the extension itself is disabled.", "\t//Writing data to the CRM may require an update, this is indicated by the \"requiresReset\" argument in the callback function.", "\t//\tIf no such argument is present in the callback (say the callback only passes one param that is the node you just edited)", "\t//\tthis means that no reset will ever be required and the change you made is instantly applied. If there is and it's true,", "\t//\tyou can call the crmapi.crm.update() function. ", "\t//\tWARNING this function will make auto-run script run twice, seeing as the original script is still running on the page ", "\t//\tand another instance is added.", "\tthis.crm = {};", "", "\t/**", "\t * Sends a message to the background script with given parameters", "\t * ", "\t * @param {string} action - What the action is", "\t * @param {function} callback - The function to run when done", "\t * @param {object} params - Any options or parameters", "\t */", "\tfunction sendCrmMessage(action, callback, params) {", "\t\tfunction onFinish(status, messageOrParams, stackTrace) {", "\t\t\tif (status === 'error') {", "\t\t\t\t_this.onError && _this.onError(messageOrParams);", "\t\t\t\tif (_this.stackTraces) {", "\t\t\t\t\tsetTimeout(function () {", "\t\t\t\t\t\tconsole.log('stack trace: ');", "\t\t\t\t\t\tstackTrace.forEach(function (line) {", "\t\t\t\t\t\t\tconsole.log(line);", "\t\t\t\t\t\t});", "\t\t\t\t\t}, 5);", "\t\t\t\t}", "\t\t\t\tif (_this.errors) {", "\t\t\t\t\tthrow new Error('CrmAPIError: ' + messageOrParams.error);", "\t\t\t\t} else {", "\t\t\t\t\tconsole.warn('CrmAPIError: ' + messageOrParams.error);", "\t\t\t\t}", "\t\t\t} else {", "\t\t\t\tcallback.apply(_this, messageOrParams);", "\t\t\t}", "\t\t}", "", "\t\tvar message = params || {};", "\t\tmessage.type = 'crm';", "\t\tmessage.id = id;", "\t\tmessage.action = action;", "\t\tmessage.crmPath = node.path;", "\t\tmessage.onFinish = onFinish;", "\t\tmessage.tabId = _this.tabId;", "\t\tsendMessage(message);", "\t}", "", "\t/**", "\t * The value of a standard node, all nodes inherit from this", "\t * ", "\t * @typedef {Object} CrmAPIInit~crmNode", "\t * @property {Number} id - The ID of the node", "\t * @property {Number} index - The index of the node in its parent's children", "\t * @property {string} name - The name of the node", "\t * @property {string} type - The type of the node (link, script, menu or divider)", "\t * @property {Object[]} children - The children of the object, only possible if type is menu and permision \"CRM\" is present", "\t * @property {Object} nodeInfo - Any info about the node, it's author and where it's downloaded from", "\t * @property {string} nodeInfo.installDate - The date on which the node was installed or created", "\t * @property {boolean} nodeInfo.isRoot - Whether the node is downloaded (false) or created locally (true)", "\t * @property {string[]} nodeInfo.permissions - Permissions required by the node on install", "\t * @property {string|Object} nodeInfo.source - 'Local' if the node is non-remotely or created here,", "\t *\t\tobject if it IS remotely installed", "\t * @property {string} nodeInfo.source.url - The url that the node was installed from", "\t * @property {Number[]} path - The path to the node from the tree's root", "\t * @property {boolean[]} onContentTypes - The content types on which the node is visible", "\t *\t\tthere's 6 slots, for each slot true indicates it's shown and false indicates it's hidden", "\t *\t\ton that content type, the content types are 'page','link','selection','image','video' and 'audio' ", "\t *\t\trespectively", "\t * @property {string[]} permissions - The permissions required by this script", "\t * @property {string} url - The URL to open", "\t * @property {string} triggers.url - The URL of the site on which to run, according to the chrome match patterns", "\t *\t\tfound at https://developer.chrome.com/extensions/match_patterns", "\t * @property {boolean} triggers.not - If true does NOT run on given site", "\t * @property {CrmAPIInit~linkVal} linkVal - The value of the node if it were to switch to type link", "\t * @property {CrmAPIInit~scriptVal} scriptVal - The value of the node if it were to switch to type script", "\t * @property {Object[]} menuVal - The children of the node if it were to switch to type menu", "\t */", "", "\t/**", "\t * The properties of a node if it's of type link", "\t * ", "\t * @augments CrmAPIInit~crmNode", "\t * @typedef {Object[]} CrmAPIInit~linkVal", "\t * @property {Object[]} value - The links in this link-node", "\t * @property {string} value.url - The URL to open", "\t * @property {boolean} value.newTab - True if the link is opened in a new tab", "\t * @property {boolean} showOnSpecified - Whether the triggers are actually used, true if they are", "\t */", "", "\t/*", "\t * The properties of a node if it's of type script", "\t * ", "\t * @augments CrmAPIInit~crmNode", "\t * @typedef {Object} CrmAPIInit~scriptVal", "\t * @property {Object} value - The value of this script-node", "\t * @property {Number} value.launchMode - When to launch the script, ", "\t *\t\t0 = run on clicking", "\t *\t\t1 = always run", "\t *\t\t2 = run on specified pages", "\t *\t\t3 = only show on specified pages", "\t * @property {Object} value - An object containing values about the script", "\t * @property {string} value.script - The script for this node", "\t * @property {Object} value.metaTags - The metaTags for the script, keys are the metaTags, values are", "\t *\t\tarrays where each item is one instance of the key-value pair being in the metatags", "\t * @property {Object[]} libraries - The libraries that are used in this script", "\t * @property {script} libraries.name - The name of the library", "\t */", "", "\t/*", "\t* The properties of a node if it's of type stylesheet", "\t* ", "\t* @augments CrmAPIInit~crmNode", "\t* @typedef {Object} CrmAPIInit~stylesheetVal", "\t* @property {Object} value - The value of this stylesheet", "\t* @property {Number} value.launchMode - When to launch the stylesheet, ", "\t*\t\t0 = run on clicking", "\t*\t\t1 = always run", "\t*\t\t2 = run on specified pages", "\t*\t\t3 = only show on specified pages", "\t* @property {string} value.stylesheet - The script that is ran itself", "\t* @property {boolean} value.toggle - Whether the stylesheet is always on or toggleable by clicking (true = toggleable)", "\t* @property {boolean} value.defaultOn - Whether the stylesheet is on by default or off, only used if toggle is true", "\t*/", "", "\t/**", "\t * The properties of a node if it's of type menu", "\t * ", "\t * @augments CrmAPIInit~crmNode", "\t * @typedef {Object} CrmAPIInit~menuVal", "\t * @property {boolean} showOnSpecified - Whether the triggers are actually used, true if they are", "\t */", "", "\t/**", "\t * The properties of a node if it's of type divider", "\t * ", "\t * @augments CrmAPIInit~crmNode", "\t * @typedef {Object} CrmAPIInit~dividerVal", "\t * @property {boolean} showOnSpecified - Whether the triggers are actually used, true if they are", "\t */", "", "\t/**", "\t * This callback is called on most crm functions", "\t * @callback CrmAPIInit~crmCallback", "\t * @param {CrmAPIInit~crmNode} node - The node that has been processed/retrieved", "\t */", "", "\t/*", "\t * Gets the CRM tree from the tree's root - requires permission \"crmGet\"", "\t * ", "\t * @param {function} callback - A function that is called when done with the data as an argument", "\t */", "\tthis.crm.getTree = function (callback) {", "\t\tsendCrmMessage('getTree', callback);", "\t}", "", "\t/*", "\t * Gets the CRM's tree from either the root or from the node with ID nodeId - requires permission \"crmGet\"", "\t * ", "\t * @param {number} nodeId - The ID of the tree's root node", "\t * @param {function} callback - A function that is called when done with the data as an argument", "\t */", "\tthis.crm.getSubTree = function (nodeId, callback) {", "\t\tsendCrmMessage('getSubTree', callback, {", "\t\t\tnodeId: nodeId", "\t\t});", "\t}", "", "\t/*", "\t * Gets the node with ID nodeId - requires permission \"crmGet\"", "\t * ", "\t * @param {CrmAPIInit~crmCallback} callback - A function that is called when done", "\t */", "\tthis.crm.getNode = function (nodeId, callback) {", "\t\tsendCrmMessage('getCrmItem', callback, {", "\t\t\tnodeId: nodeId", "\t\t});", "\t}", "", "\t/*", "\t * Gets a node's ID from a path to the node - requires permission \"crmGet\"", "\t * ", "\t * @param {number[]} path - An array of numbers representing the path, each number", "\t *\t\trepresents the n-th child of the current node, so [1,2] represents the 2nd item(0,>1<,2)'s third child (0,1,>2<,3)", "\t * @param {function} callback - The function that is called with the ID as an argument", "\t */", "\tthis.crm.getNodeIdFromPath = function (path, callback) {", "\t\tsendCrmMessage('getNodeIdFromPath', callback, {", "\t\t\tpath: path", "\t\t});", "\t}", "", "\t/**", "\t * Queries the CRM for any items matching your query - requires permission \"crmGet\"", "\t * ", "\t * @param {crmCallback} - callback The function to call when done, returns one array of results", "\t * @param {Object} query - The query to look for", "\t * @param {string} [query.name] - The name of the item", "\t * @param {string} [query.type] - The type of the item (link, script, divider or menu)", "\t * @param {number} [query.inSubTree] - The subtree in which this item is located (the number given is the id of the root item)", "\t * @param {CrmAPIInit~crmCallback} callback - A callback with the results in an array", "\t */", "\tthis.crm.queryCrm = function (query, callback) {", "\t\tsendCrmMessage('queryCrm', callback, {", "\t\t\tquery: query", "\t\t});", "\t}", "", "\t/**", "\t * Gets the parent of the node with ID nodeId - requires permission \"crmGet\"", "\t * ", "\t * @param {number} nodeId - The node of which to get the parent", "\t * @param {CrmAPIInit~crmCallback} callback - A callback with the parent of the given node as an argument", "\t */", "\tthis.crm.getParentNode = function (nodeId, callback) {", "\t\tsendCrmMessage('getParentNode', callback, {", "\t\t\tnodeId: nodeId", "\t\t});", "\t}", "", "\t/**", "\t * Gets the children of the node with ID nodeId - requires permission \"crmGet\"", "\t * ", "\t * @param {number} nodeId - The id of the node whose children to get", "\t * @param {function} callback - A callback with an array of CrmAPIInit~crmNode nodes as the parameter", "\t */", "\tthis.crm.getChildren = function (nodeId, callback) {", "\t\tsendCrmMessage('getChildren', callback, {", "\t\t\tnodeId: nodeId", "\t\t});", "\t}", "", "\t/**", "\t * Gets the type of node with ID nodeId - requires permission \"crmGet\"", "\t * ", "\t * @param {number} nodeId - The id of the node whose type to get", "\t * @param {function} callback - A callback with the type of the node as the parameter (link, script, menu or divider)", "\t */", "\tthis.crm.getNodeType = function (nodeId, callback) {", "\t\tsendCrmMessage('getNodeType', callback, {", "\t\t\tnodeId: nodeId", "\t\t});", "\t}", "", "\t/**", "\t * Gets the value of node with ID nodeId - requires permission \"crmGet\"", "\t * ", "\t * @param {number} nodeId - The id of the node whose value to get", "\t * @param {function} callback - A callback with parameter CrmAPIInit~linkVal, CrmAPIInit~scriptVal, CrmAPIInit~stylesheetVal or an empty object depending on type", "\t */", "\tthis.crm.getNodeValue = function (nodeId, callback) {", "\t\tsendCrmMessage('getNodeValue', callback, {", "\t\t\tnodeId: nodeId", "\t\t});", "\t}", "", "\t/**", "\t * Creates a node with the given options - requires permission \"crmGet\" and \"crmWrite\"", "\t * ", "\t * @param {Object} options - An object containing all the options for the node", "\t * @param {object} [options.position] - An object containing info about where to place the item, defaults to last if not given", "\t * @param {number} [options.position.node] - The other node, if not given, \"relates\" to the root", "\t * @param {string} [options.position.relation] - The position relative to the other node, possibilities are:", "\t *\t\tfirstChild: becomes the first child of given node, throws an error if given node is not of type menu", "\t *\t\tfirstSibling: first of the subtree that given node is in", "\t *\t\tlastChild: becomes the last child of given node, throws an error if given ndoe is not of type menu", "\t *\t\tlastSibling: last of the subtree that given node is in", "\t *\t\tbefore: before given node", "\t *\t\tafter: after the given node", "\t * @param {string} [options.name] - The name of the object, not required, defaults to \"name\"", "\t * @param {string} [options.type] - The type of the node (link, script, divider or menu), not required, defaults to link", "\t * @param {boolean} [options.usesTriggers] - Whether the node uses triggers to launch or if it just always launches (only applies to", "\t *\t\tlink, menu and divider)", "\t * @param {Object[]} [options.triggers] - An array of objects telling the node to show on given triggers. (only applies to link,", "\t *\t\t menu and divider)", "\t * @param {string} [options.triggers.url ] - The URL to show the node on", "\t * @param {Object[]} [options.linkData] - The links to which the node of type \"link\" should... link (defaults to example.com in a new tab),", "\t *\t\tconsists of an array of objects each containg a URL property and a newTab property, the url being the link they open and the", "\t *\t\tnewTab boolean being whether or not it opens in a new tab.", "\t * @param {string} [options.linkData.url] - The url to open when clicking the link, this value is required.", "\t * @param {boolean} [options.linkData.newTab] - Whether or not to open the link in a new tab, not required, defaults to true", "\t * @param {Object} [options.scriptData] - The data of the script, required if type is script", "\t * @param {string} [options.scriptData.script] - The actual script, will be \"\" if none given, required", "\t * @param {Number} [options.scriptData.launchMode] - The time at which this script launches, not required, defaults to 0,", "\t *\t\t0 = run on clicking", "\t *\t\t1 = always run", "\t *\t\t2 = run on specified pages", "\t *\t\t3 = only show on specified pages", "\t * @param {Object[]} [options.scriptData.triggers] - A trigger for the script to run, not required", "\t * @param {string} [options.scriptData.triggers.url] - The URL of the site on which to run, regex is available but wrap it in parentheses", "\t * @param {Object[]} [options.scriptData.libraries] - The libraries for the script to include, if the library is not yet", "\t *\t\tregistered throws an error, so do that first, not required", "\t * @param {string} [options.scriptData.libraries.name] - The name of the library", "\t * @param {Object] [options.stylesheetData] - The data of the stylesheet, required if type is stylesheet", "\t * @param {Number} [options.stylesheetData.launchMode] - The time at which this stylesheet launches, not required, defaults to 0,", "\t *\t\t0 = run on clicking", "\t *\t\t1 = always run", "\t *\t\t2 = run on specified pages", "\t *\t\t3 = only show on specified pages", "\t * @param {string} [options.stylesheetData.stylesheet] - The stylesheet that is ran itself", "\t * @property {boolean} [options.stylesheetData.toggle] - Whether the stylesheet is always on or toggleable by clicking (true = toggleable), not required, defaults to true", "     * @property {boolean} [options.stylesheetData.defaultOn] - Whether the stylesheet is on by default or off, only used if toggle is true, not required, defaults to true", "     * @param {Object[]} [options.stylesheetData.triggers] - A trigger for the stylesheet to run, not required", "\t * @param {string} [options.stylesheetData.triggers.url] - The URL of the site on which to run, regex is available but wrap it in parentheses", "\t * @param {CrmAPIInit~crmCallback} callback - A callback given the new node as an argument", "\t */", "\tthis.crm.createNode = function (options, callback) {", "\t\tsendCrmMessage('createNode', callback, {", "\t\t\toptions: options", "\t\t});", "\t}", "", "\t/**", "\t * Copies given node, - requires permission \"crmGet\" and \"crmWrite\"", "\t * WARNNG: following properties are not copied:", "\t *\t\tfile, storage, id, permissions, nodeInfo", "\t *\t\tFull permissions rights only if both the to be cloned and the script executing this have full rights", "\t * ", "\t * @param {number} nodeId - The id of the node to copy", "\t * @param {Object} options - An object containing all the options for the node", "\t * @param {string} [options.name] - The new name of the object (same as the old one if none given)", "\t * @param {object} [options.position] - An object containing info about where to place the item, defaults to last if not given", "\t * @param {number} [options.position.node] - The other node, if not given, \"relates\" to the root", "\t * @param {string} [options.position.relation] - The position relative to the other node, possibilities are:", "\t *\t\tfirstChild: becomes the first child of given node, throws an error if given node is not of type menu", "\t *\t\tfirstSibling: first of the subtree that given node is in", "\t *\t\tlastChild: becomes the last child of given node, throws an error if given ndoe is not of type menu", "\t *\t\tlastSibling: last of the subtree that given node is in", "\t *\t\tbefore: before given node", "\t *\t\tafter: after the given node", "\t * @param {CrmAPIInit~crmCallback} callback - A callback given the new node as an argument", "\t */", "\tthis.crm.copyNode = function (nodeId, options, callback) {", "\t\toptions = options || {};", "\t\t//To prevent the user's stuff from being disturbed if they re-use the object", "\t\tvar optionsCopy = JSON.parse(JSON.stringify(options));", "\t\tsendCrmMessage('copyNode', callback, {", "\t\t\tnodeId: nodeId,", "\t\t\toptions: optionsCopy", "\t\t});", "\t}", "", "\t/**", "\t * Moves given node to position specified in \"position\" - requires permission \"crmGet\" and \"crmWrite\"", "\t * ", "\t * @param {number} nodeId - The id of the node to move", "\t * @param {Object} [position] - An object containing info about where to place the item, defaults to last child of root if not given", "\t * @param {number} [position.node] - The other node, if not given, \"relates\" to the root", "\t * @param {string} [position.relation] - The position relative to the other node, possibilities are:", "\t *\t\tfirstChild: becomes the first child of given node, throws an error if given node is not of type menu", "\t *\t\tfirstSibling: first of the subtree that given node is in", "\t *\t\tlastChild: becomes the last child of given node, throws an error if given ndoe is not of type menu", "\t *\t\tlastSibling: last of the subtree that given node is in", "\t *\t\tbefore: before given node", "\t *\t\tafter: after the given node", "\t * @param {CrmAPIInit~crmCallback} callback - A function that gets called with the new node as an argument", "\t */", "\tthis.crm.moveNode = function (nodeId, position, callback) {", "\t\tposition = position || {};", "\t\t//To prevent the user's stuff from being disturbed if they re-use the object", "\t\tvar positionCopy = JSON.parse(JSON.stringify(position));", "\t\tsendCrmMessage('moveNode', callback, {", "\t\t\tnodeId: nodeId,", "\t\t\tposition: positionCopy", "\t\t});", "\t}", "", "\t/**", "\t * Deletes given node - requires permission \"crmGet\" and \"crmWrite\"", "\t * ", "\t * @param {number} nodeId - The id of the node to delete", "\t * @param {function} callback - A function to run when done, contains an argument containing true if it worked, otherwise containing the error message", "\t */", "\tthis.crm.deleteNode = function (nodeId, callback) {", "\t\tsendCrmMessage('deleteNode', callback, {", "\t\t\tnodeId: nodeId", "\t\t});", "\t}", "", "\t/**", "\t * Edits given settings of the node - requires permission \"crmGet\" and \"crmWrite\"", "\t * ", "\t * @param {number} nodeId - The id of the node to edit", "\t * @param {Object} options - An object containing the settings for what to edit", "\t * @param {string} [options.name] - Changes the name to given string", "\t * @param {string} [options.type] - The type to switch to (link, script, stylesheet, divider or menu)", "\t * @param {CrmAPIInit~crmCallback} callback - A function to run when done, contains the new node as an argument", "\t */", "\tthis.crm.editNode = function (nodeId, options, callback) {", "\t\toptions = options || {};", "\t\t//To prevent the user's stuff from being disturbed if they re-use the object", "\t\tvar optionsCopy = JSON.parse(JSON.stringify(options));", "\t\tsendCrmMessage('editNode', callback, {", "\t\t\toptions: optionsCopy,", "\t\t\tnodeId: nodeId", "\t\t});", "\t}", "", "\t/**", "\t * Gets the triggers for given node - requires permission \"crmGet\"", "\t * ", "\t * @param {number} nodeId - The node of which to get the triggers", "\t * @param {CrmAPIInit~crmCallback} callback - A function to run when done, with the triggers as an argument", "\t */", "\tthis.crm.getTriggers = function (nodeId, callback) {", "\t\tsendCrmMessage('getTriggers', callback, {", "\t\t\tnodeId: nodeId", "\t\t});", "\t}", "", "\t/**", "\t * Sets the triggers for given node - requires permissions \"crmGet\" and \"crmSet\"", "\t * ", "\t * @param {number} nodeId - The node of which to get the triggers", "\t * @param {Object[]} triggers - The triggers that launch this node, automatically turns triggers on", "\t * @param {string} triggers.url - The url of the trigger", "\t * @param {boolean} triggers.not - If true does NOT show the node on that URL", "\t * @param {CrmAPIInit~crmCallback} callback - A function to run when done, with the node as an argument", "\t */", "\tthis.crm.setTriggers = function (nodeId, triggers, callback) {", "\t\tsendCrmMessage('setTriggers', callback, {", "\t\t\tnodeId: nodeId,", "\t\t\ttriggers: triggers", "\t\t});", "\t}", "", "\t/**", "\t * Gets the trigger' usage for given node (true - it's being used, or false), only works on", "\t *\t\tlink, menu and divider - requires permission \"crmGet\"", "\t * ", "\t * @param {number} nodeId - The node of which to get the triggers", "\t * @param {CrmAPIInit~crmCallback} callback - A function to run when done, with the triggers' usage as an argument", "\t */", "\tthis.crm.stylesheet.getTriggerUsage = function (nodeId, callback) {", "\t\tsendCrmMessage('getTriggerUsage', callback, {", "\t\t\tnodeId: nodeId", "\t\t});", "\t}", "", "\t/**", "\t * Sets the usage of triggers for given node, only works on link, menu and divider", "\t *\t\t - requires permissions \"crmGet\" and \"crmSet\"", "\t * ", "\t * @param {number} nodeId - The node of which to get the triggers", "\t * @param {boolean} useTriggers - Whether the triggers should be used or not", "\t * @param {CrmAPIInit~crmCallback} callback - A function to run when done, with the node as an argument", "\t */", "\tthis.crm.stylesheet.setTriggerUsage = function (nodeId, useTriggers, callback) {", "\t\tsendCrmMessage('setTriggerUsage', callback, {", "\t\t\tnodeId: nodeId,", "\t\t\tuseTriggers: useTriggers", "\t\t});", "\t}", "", "\t/**", "\t * Gets the content types for given node - requires permission \"crmGet\"", "\t * ", "\t * @param {number} nodeId - The node of which to get the content types", "\t * @param {CrmAPIInit~crmCallback} callback - A function to run when done, with the content types array as an argument", "\t */", "\tthis.crm.getContentTypes = function (nodeId, callback) {", "\t\tsendCrmMessage('getContentTypes', callback, {", "\t\t\tnodeId: nodeId", "\t\t});", "\t}", "", "\t/**", "\t * Sets the content type at index \"index\" to given value \"value\"- requires permissions \"crmGet\" and \"crmWrite\"", "\t * ", "\t * @param {number} nodeId - The node whose content types to set", "\t * @param {number} index - The index of the array to set, 0-5, ordered this way: ", "\t *\t\tpage, link, selection, image, video, audio", "\t * @param {boolean} value - The new value at index \"index\"", "\t * @param {CrmAPIInit~crmCallback} callback - A function to run when done, with the new array as an argument", "\t */", "\tthis.crm.setContentType = function (nodeId, index, value, callback) {", "\t\tsendCrmMessage('setContentType', callback, {", "\t\t\tindex: index,", "\t\t\tvalue: value,", "\t\t\tnodeId: nodeId", "\t\t});", "\t}", "", "\t/**", "\t * Sets the content types to given contentTypes array - requires permissions \"crmGet\" and \"crmWrite\"", "\t * ", "\t * @param {number} nodeId - The node whose content types to set", "\t * @param {string[]} contentTypes - An array of strings, if a string is present it means that it is displayed", "\t *\t\ton that content type. Requires at least one type to be active, otherwise all are activated.", "\t *\t\tThe options are:", "\t *\t\tpage, link, selection, image, video, audio", "\t * @param {CrmAPIInit~crmCallback} callback - A function to run when done, with the node as an argument", "\t */", "\tthis.crm.setContentTypes = function (nodeId, contentTypes, callback) {", "\t\tsendCrmMessage('setContentTypes', callback, {", "\t\t\tcontentTypes: contentTypes,", "\t\t\tnodeId: nodeId", "\t\t});", "\t}", "", "\t/*", "\t * Any settings changed on nodes that are currently not of the type of which you change the settings (using crmAPI.crm.link.push on a script)", "\t * will take effect when the type is changed to the one you are editing (link in the previous example) at any point in the future.", "\t * This is ofcourse not true if the settings for link are changed in the meantime, but any other settings can be changed without it being", "\t * affected (script, menu, divider, name, type etc.)", "\t */", "", "\tthis.crm.link = {};", "", "\t/**", "\t * Gets the links of the node with ID nodeId - requires permission \"crmGet\"", "\t * ", "\t * @param {number} nodeId - The id of the node to get the links from", "\t * @param {function} callback - A callback with an array of objects as parameters, each containg two keys: ", "\t *\t\tnewTab: Whether the link should open in a new tab or the current tab", "\t *\t\tvalue: The URL of the link ", "\t */", "\tthis.crm.link.getLinks = function (nodeId, callback) {", "\t\tsendCrmMessage('linkGetLinks', callback, {", "\t\t\tnodeId: nodeId", "\t\t});", "\t}", "", "\t/**", "\t * Pushes given items into the array of URLs of node with ID nodeId - requires permission \"crmGet\" and \"crmWrite\"", "\t * ", "\t * @param {number} nodeId - The node to push the items to", "\t * @param {Object[]|Object} items - An array of items or just one item to push", "\t * @param {boolean} [items.newTab] - Whether the link should open in a new tab, defaults to true", "\t * @param {string} [items.url] - The URL to open on clicking the link", "\t * @param {functon} callback - A function that gets called when done with the new array as an argument", "\t */", "\tthis.crm.link.push = function (nodeId, items, callback) {", "\t\tsendCrmMessage('linkPush', callback, {", "\t\t\titems: items,", "\t\t\tnodeId: nodeId", "\t\t});", "\t};", "", "\t/**", "\t * Splices the array of URLs of node with ID nodeId. Start at \"start\" and splices \"amount\" items (just like array.splice)", "\t * and returns them as an array in the callback function - requires permission \"crmGet\" and \"crmWrite\"", "\t * ", "\t * @param {number} nodeId - The node to splice", "\t * @param {nunber} start - The index of the array at which to start splicing", "\t * @param {nunber} amount - The amount of items to splice", "\t * @param {function} callback - A function that gets called with the spliced items as the first parameter and the new array as the second parameter", "\t */", "\tthis.crm.link.splice = function (nodeId, start, amount, callback) {", "\t\tsendCrmMessage('linkSplice', callback, {", "\t\t\tnodeId: nodeId,", "\t\t\tstart: start,", "\t\t\tamount: amount", "\t\t});", "\t}", "", "", "\tthis.crm.script = {};", "", "\t/**", "\t * Sets the launch mode of node with ID nodeId to \"launchMode\" - requires permission \"crmGet\" and \"crmWrite\"", "\t * ", "\t * @param {number} nodeId - The node to edit", "\t * @param {number} launchMode - The new launchMode, which is the time at which this script runs", "\t * \t\t0 = run on clicking", "\t *\t\t1 = always run", "\t *\t\t2 = run on specified pages", "\t *\t\t3 = only show on specified pages", "\t * @param {CrmAPIInit~crmCallback} callback - A function that is ran when done with the new node as an argument", "\t */", "\tthis.crm.script.setLaunchMode = function (nodeId, launchMode, callback) {", "\t\tsendCrmMessage('setScriptLaunchMode', callback, {", "\t\t\tnodeId: nodeId,", "\t\t\tlaunchMode: launchMode", "\t\t});", "\t}", "", "\t/**", "\t * Gets the launchMode of the node with ID nodeId - requires permission \"crmGet\"", "\t * ", "\t * @param {number} nodeId - The id of the node to get the launchMode of", "\t * @param {function} callback - A callback with the launchMode as an argument", "\t */", "\tthis.crm.script.getLaunchMode = function (nodeId, callback) {", "\t\tsendCrmMessage('getScriptLaunchMode', callback, {", "\t\t\tnodeId: nodeId", "\t\t});", "\t}", "", "\tthis.crm.script.libraries = {};", "\t/**", "\t * Pushes given libraries to the node with ID nodeId's libraries array,", "\t * make sure to register them first or an error is thrown - requires permission \"crmGet\" and \"crmWrite\"", "\t * ", "\t * @param {number} nodeId - The node to edit", "\t * @param {Object[]|Object} libraries - One library or an array of libraries to push", "\t * @param {string} - libraries.name - The name of the library", "\t * @param {function} callback - A callback with the new array as an argument", "\t */", "\tthis.crm.script.libraries.push = function (nodeId, libraries, callback) {", "\t\tsendCrmMessage('scriptLibraryPush', callback, {", "\t\t\tnodeId: nodeId,", "\t\t\tlibraries: libraries", "\t\t});", "\t}", "", "\t/**", "\t * Splices the array of libraries of node with ID nodeId. Start at \"start\" and splices \"amount\" items (just like array.splice)", "\t * and returns them as an array in the callback function - requires permission \"crmGet\" and \"crmWrite\"", "\t * ", "\t * @param {number} nodeId - The node to splice", "\t * @param {nunber} start - The index of the array at which to start splicing", "\t * @param {nunber} amount - The amount of items to splice", "\t * @param {function} callback - A function that gets called with the spliced items as the first parameter and the new array as the second parameter", "\t */", "\tthis.crm.script.libraries.splice = function (nodeId, start, amount, callback) {", "\t\tsendCrmMessage('scriptLibrarySplice', callback, {", "\t\t\tnodeId: nodeId,", "\t\t\tstart: start,", "\t\t\tamount: amount", "\t\t});", "\t}", "", "\t/**", "\t * Sets the script of node with ID nodeId to value \"script\" - requires permission \"crmGet\" and \"crmWrite\"", "\t * ", "\t * @param {number} nodeId - The node of which to change the script", "\t * @param {string} value - The code to change to", "\t * @param {CrmAPIInit~crmCallback} callback - A function with the node as an argument", "\t */", "\tthis.crm.script.setScript = function (nodeId, script, callback) {", "\t\tsendCrmMessage('setScriptValue', callback, {", "\t\t\tnodeId: nodeId,", "\t\t\tscript: script", "\t\t});", "\t}", "", "\t/**", "\t * Gets the value of the script - requires permission \"crmGet\"", "\t * ", "\t * @param {number} nodeId - The id of the node of which to get the script", "\t * @param {function} callback - A callback with the script's value as an argument", "\t */", "\tthis.crm.script.getScript = function (nodeId, callback) {", "\t\tsendCrmMessage('getScriptValue', callback, {", "\t\t\tnodeId: nodeId", "\t\t});", "\t}", "", "", "\tthis.crm.menu = {};", "", "\t/**", "\t * Gets the children of the node with ID nodeId - requires permission \"crmGet\"", "\t * ", "\t * @param {number} nodeId - The id of the node of which to get the children", "\t * @param {CrmAPIInit~crmCallback} callback - A callback with the node as an argument", "\t */", "\tthis.crm.menu.getChildren = function (nodeId, callback) {", "\t\tsendCrmMessage('getMenuChildren', callback, {", "\t\t\tnodeId: nodeId", "\t\t});", "\t}", "", "\t/**", "\t * Sets the children of node with ID nodeId to the nodes with IDs childrenIds - requires permission \"crmGet\" and \"crmWrite\"", "\t * ", "\t * @param {number} nodeId - The id of the node of which to set the children", "\t * @param {number[]} childrenIds - Each number in the array represents a node that will be a new child", "\t * @param {CrmAPIInit~crmCallback} callback - A callback with the node as an argument", "\t */", "\tthis.crm.menu.setChildren = function (nodeId, childrenIds, callback) {", "\t\tsendCrmMessage('setMenuChildren', callback, {", "\t\t\tnodeId: nodeId,", "\t\t\tchildrenIds: childrenIds", "\t\t});", "\t}", "", "\t/**", "\t * Pushes the nodes with IDs childrenIds to the node with ID nodeId - requires permission \"crmGet\" and \"crmWrit\"", "\t * ", "\t * @param {number} nodeId - The id of the node of which to push the children", "\t * @param {number[]} childrenIds - Each number in the array represents a node that will be a new child", "\t * @param {CrmAPIInit~crmCallback} callback - A callback with the node as an argument", "\t */", "\tthis.crm.menu.push = function (nodeId, childrenIds, callback) {", "\t\tsendCrmMessage('pushMenuChildren', callback, {", "\t\t\tnodeId: nodeId,", "\t\t\tchildrenIds: childrenIds", "\t\t});", "\t}", "", "\t/**", "\t * Splices the children of the node with ID nodeId, starting at \"start\" and splicing \"amount\" items, ", "\t * the removed items will be put in the root of the tree instead - requires permission \"crmGet\" and \"crmWrite\"", "\t * ", "\t * @param {number} nodeId - The id of the node of which to splice the children", "\t * @param {number} start - The index at which to start", "\t * @param {number} amount - The amount to splice", "\t * @param {function} callback - A function that gets called with the spliced items as the first parameter and the new array as the second parameter", "\t */", "\tthis.crm.menu.splice = function (nodeId, start, amount, callback) {", "\t\tsendCrmMessage('spliceMenuChildren', callback, {", "\t\t\tnodeId: nodeId,", "\t\t\tchildrenIds: childrenIds", "\t\t});", "\t}", "", "\tthis.libraries = {};", "\t/**", "\t * Registers a library with name \"name\", requires permission \"crmWrite\"", "\t * ", "\t * @param {string} name - The name to give the library", "\t * @param {Object} options - The options related to the library", "\t * @param {string} [options.url] - The url to fetch the code from, must end in .js", "\t * @param {string} [options.code] - The code to use", "\t * @param {function} callback - A callback with the library object as an argument", "\t */", "\tthis.libraries.register = function (name, options, callback) {", "\t\tsendCrmMessage('registerLibrary', callback, {", "\t\t\tname: name,", "\t\t\turl: options.url,", "\t\t\tcode: options.code", "\t\t});", "\t}", "\t//#endregion", "", "\t//#region Chrome APIs", "\tfunction ChromeRequest(api, type) {", "\t\tthis.api = api;", "\t\tObject.defineProperty(this, \"type\", {", "\t\t\tget: function() { ", "\t\t\t\treturn type;", "\t\t\t}", "\t\t});", "\t\treturn this;", "\t}", "", "\tChromeRequest.prototype.chromeAPIArguments = [];", "", "\t/**", "\t * Uses given arguments as arguments for the API in order specified. WARNING this can NOT be ", "\t * a function, for functions refer to the other two types.", "\t */", "\tChromeRequest.prototype.args = function () {", "\t\tfor (var i = 0; i < arguments.length; i++) {", "\t\t\tthis.chromeAPIArguments.push({", "\t\t\t\ttype: 'arg',", "\t\t\t\tval: jsonFn.stringify(arguments[i])", "\t\t\t});", "\t\t}", "\t\treturn this;", "\t}", "", "\t/*", "\t * A function that will preserve scope but is not passed to the chrome API itself.", "\t * Instead a placeholder is passed that will take any arguments the chrome API passes to it", "\t * and calls your fn function with local scope with the arguments the chrome API passed. Keep in", "\t * mind that there is no connection between your function and the chrome API, the chrome API only", "\t * sees a placeholder function with which it can do nothing so don't use this as say a forEach handler.", "\t */", "\tChromeRequest.prototype.fn = function (fn) {", "\t\tthis.chromeAPIArguments.push({", "\t\t\ttype: 'fn',", "\t\t\tval: _this.createCallback(fn, new Error)", "\t\t});", "\t\treturn this;", "\t}", "", "\t/*", "\t * A function that is called with the value that the chrome API returned. This can", "\t * be used for APIs that don't use callbacks and instead just return values such as", "\t * chrome.runtime.getURL().", "\t */", "\tChromeRequest.prototype.return = function (fn) {", "\t\tthis.chromeAPIArguments.push({", "\t\t\ttype: 'return',", "\t\t\tval: _this.createCallback(fn, new Error)", "\t\t});", "\t\treturn this;", "\t}", "", "\t/*", "\t * Executes the request", "\t */", "\tChromeRequest.prototype.send = function () {", "\t\tvar message = {", "\t\t\ttype: 'chrome',", "\t\t\tid: id,", "\t\t\tapi: this.api,", "\t\t\targs: this.chromeAPIArguments,", "\t\t\ttabId: _this.tabId,", "\t\t\trequestType: this.type,", "\t\t\tonFinish: function (status, messageOrParams, stackTrace) {", "\t\t\t\tif (status === 'error' || status === 'chromeError') {", "\t\t\t\t\tif (this.onError) {", "\t\t\t\t\t\tthis.onError(messageOrParams);", "\t\t\t\t\t}", "\t\t\t\t\telse if (_this.onError) {", "\t\t\t\t\t\t_this.onError(messageOrParams);", "\t\t\t\t\t}", "\t\t\t\t\tif (_this.stackTraces) {", "\t\t\t\t\t\tsetTimeout(function () {", "\t\t\t\t\t\t\tif (messageOrParams.stackTrace) {", "\t\t\t\t\t\t\t\tconsole.warn('Remote stack trace:');", "\t\t\t\t\t\t\t\tmessageOrParams.stackTrace.forEach(function (line) {", "\t\t\t\t\t\t\t\t\tconsole.warn(line);", "\t\t\t\t\t\t\t\t});", "\t\t\t\t\t\t\t}", "\t\t\t\t\t\t\tconsole.warn((messageOrParams.stackTrace ? 'Local s' : 'S') + 'tack trace:');", "\t\t\t\t\t\t\tstackTrace.forEach(function (line) {", "\t\t\t\t\t\t\t\tconsole.warn(line);", "\t\t\t\t\t\t\t});", "\t\t\t\t\t\t}, 5);", "\t\t\t\t\t}", "\t\t\t\t\tif (_this.errors) {", "\t\t\t\t\t\tthrow new Error('CrmAPIError: ' + messageOrParams.error);", "\t\t\t\t\t} else if (!this.onError) {", "\t\t\t\t\t\tconsole.warn('CrmAPIError: ' + messageOrParams.error);", "\t\t\t\t\t}", "\t\t\t\t} else {", "\t\t\t\t\tcallInfo[messageOrParams.callbackId].callback.apply(window, messageOrParams.params);", "\t\t\t\t\tdelete callInfo[messageOrParams.callbackId];", "\t\t\t\t}", "\t\t\t}", "\t\t};", "\t\tsendMessage(message);", "\t}", "", "\t/**", "\t * Calls the chrome API given in the \"API\" parameter. Due to some issues with the chrome message passing", "\t *\t\tAPI it is not possible to pass messages and preserve scope. This could be fixed in other ways but", "\t *\t\tunfortunately chrome.tabs.executeScript (what is used to execute scripts on the page) runs in a", "\t *\t\tsandbox and does not allow you to access a lot. As a solution to this there are a few types of", "\t *\t\tfunctions you can chain-call on the crmAPI.chrome(API) object: ", "\t *\t\t\targs: uses given arguments as arguments for the API in order specified. WARNING this can NOT be ", "\t *\t\t\t\ta function, for functions refer to the other two types.", "\t * ", "\t *\t\t\tfn: a function that will preserve scope but is not passed to the chrome API itself.", "\t *\t\t\t\tInstead a placeholder is passed that will take any arguments the chrome API passes to it", "\t *\t\t\t\tand calls your fn function, that you can use with local scope, with a container argument. ", "\t *\t\t\t\tKeep in mind that there is no conection between your function and the chrome API, the chrome", "\t *\t\t\t\tAPI only sees a placeholder function with which it can do nothing so don't use this as say a", "\t *\t\t\t\tforEach handler.", "\t * ", "\t *\t\t\treturn: a function that is called with the value that the chrome API returned. This can", "\t *\t\t\t\tbe used for APIs that don't use callbacks and instead just return values such as", "\t *\t\t\t\tchrome.runtime.getURL(). This just like fn returns a container argument for", "\t *\t\t\t\tall diferent values where \"APIVal\" is the value the API returned instead of APIArgs being used.", "\t * ", "\t *\t\t\tsend: executes the request", "\t * ", "\t * Examples:", "\t *\t\t- For a function that uses callback, this is NOT the actual use of the chrome.runtime.getPlatformInfo API", "\t *\t\tcrmAPI.chrome('runtime.getPlatformInfo').args({", "\t *\t\t\tmessage: 'hello'", "\t *\t\t}).fn(function(result1, resul2) {", "\t *\t\t\tconsole.log(result1);", "\t *\t\t\tconsole.log(result2);", "\t *\t\t}).args(parameter).args(parameter1, parameter2).fn(function(result) {", "\t *\t\t\tconsole.log(result);", "\t *\t\t}).send();", "\t * ", "\t *\t\t- For a function that returns a value, this is NOT how to actually use the chrome.runtime.getUrl API", "\t *\t\tcrmAPI.chrome('runtime.getURL').args('url.html').args(parameter).fn(function(result) {", "\t *\t\t\tconsole.log(result);", "\t *\t\t}).return(function(result) {", "\t *\t\t\tconsole.log(result);", "\t *\t\t}).send();", "\t * ", "\t *\t\t- Actual real-use examples", "\t *\t\tcrmAPI.chrome('tabs.create').args(properties).fn(function(result) {", "\t *\t\t\tconsole.log(result);", "\t *\t\t}).send();", "\t * ", "\t *\t\tcrmAPI.chrome('runtime.getUrl').args(path).return(function(result) {", "\t *\t\t\tconsole.log(result);", "\t *\t\t}).send();", "\t * ", "\t * Requires permission \"chrome\" and the permission of the the API, so chrome.bookmarks requires", "\t * permission \"bookmarks\", chrome.alarms requires \"alarms\"", "\t * ", "\t * @param {string} api - The API to use", "\t * @returns {Object} - An object on which you can call .args, .fn, .return and .send", "\t */", "\tthis.chrome = function (api) {", "\t\treturn new ChromeRequest(api);", "\t};", "", "\tfunction chromeSpecialRequest(api, type) {", "\t\treturn new ChromeRequest(api, type);", "\t}", "", "\t//#endregion", "", "\t//#region GreaseMonkey Compatibility Functions", "", "\t//Documentation can be found here http://wiki.greasespot.net/Greasemonkey_Manual:API ", "\t//\tand here http://tampermonkey.net/documentation.php", "\tthis.GM = {};", "", "\t//TODO", "\tthis.GM.GM_info = function () {", "\t\treturn {", "\t\t\tscript: {},", "\t\t\tscriptMetaStr: 0,", "\t\t\tscriptWillUpdate: false,", "\t\t\tversion: greasemonkeyData", "\t\t}", "\t};", "", "\t/**", "\t * This method retrieves a value that was set with GM_setValue. See GM_setValue ", "\t *\t\tfor details on the storage of these values.", "\t * ", "\t * @param {String} name - The property name to get", "\t * @param {any} [defaultValue] - Any value to be returned, when no value has previously been set", "\t * @returns {any} Returns the value if the value is defined, if it's undefined, returns defaultValue", "\t *\t\tif defaultValue is also undefined, returns undefined", "\t */", "\tthis.GM.GM_getValue = function (name, defaultValue) {", "\t\tvar result = _this.storage.get(name);", "\t\treturn (result !== undefined ? result : defaultValue);", "\t}", "", "\t/**", "\t * This method allows user script authors to persist simple values across page-loads.", "\t * ", "\t * @param {String} name - The unique (within this script) name for this value. Should be restricted to valid Javascript identifier characters.", "\t * @param {any} value - The value to store", "\t */", "\tthis.GM.GM_setValue = function (name, value) {", "\t\t_this.storage.set(name, value);", "\t}", "", "\t/**", "\t * This method deletes an existing name / value pair from storage.", "\t * ", "\t * @param {String} name - Property name to delete.", "\t */", "\tthis.GM.GM_deleteValue = function (name) {", "\t\t_this.storage.remove(name);", "\t}", "", "\t/**", "\t * This method retrieves an array of storage keys that this script has stored.", "\t * ", "\t * @returns {String[]} All keys of the storage", "\t */", "\tthis.GM.GM_listValues = function () {", "\t\tvar keys = [];", "\t\tfor (var key in _this.storage) {", "\t\t\tif (_this.storage.hasOwnProperty(key)) {", "\t\t\t\tkeys.push(key);", "\t\t\t}", "\t\t}", "\t\treturn keys;", "\t}", "", "\t/**", "\t * Gets the resource URL for given resource name", "\t * ", "\t * @param {String} name - The name of the resource", "\t * @returns {String} A URL that can be used to get the resource value", "\t */", "\tthis.GM.GM_getResourceURL = function (name) {", "\t\treturn greasemonkeyData.resources[name].crmUrl;", "\t}", "", "\t/**", "\t * Gets the resource string for given resource name", "\t * ", "\t * @param {String} name - The name of the resource", "\t * @returns {String} The resource value", "\t */", "\tthis.GM.GM_getResourceString = function (name) {", "\t\treturn greasemonkeyData.resources[name].string;", "\t}", "", "\t/**", "\t * This method adds a string of CSS to the document. It creates a new <style> element,", "\t *\t\t adds the given CSS to it, and inserts it into the <head>.", "\t * ", "\t * @param {String} css - The CSS to put on the page", "\t */", "\tthis.GM.GM_addStyle = function (css) {", "\t\tvar style = document.createElement('style');", "\t\tstyle.appendChild(document.createTextNode(css));", "\t\tdocument.head.appendChild(style);", "\t}", "", "\t/**", "\t * Logs to the console", "\t */", "\tthis.GM.GM_log = console.log;", "", "\t/**", "\t * Open specified URL in a new tab, open_in_background is not available here since that ", "\t *\t\tnot possible in chrome", "\t * ", "\t * @param {String} url - The url to open", "\t */", "\tthis.GM.GM_openInTab = function (url) {", "\t\twindow.open(url);", "\t}", "", "\t//This is only here to prevent errors from occuring when calling any of these functions,", "\t//this function does nothing", "\tthis.GM.GM_registerMenuCommand = this.GM.GM_unregisterMenuCommand = this.GM.GM_setClipboard = emptyFn;", "", "\t//Taken from https://gist.github.com/arantius/3123124", "\tfunction setupRequestEvent(aOpts, aReq, aEventName) {", "\t\t'use strict';", "\t\tif (!aOpts['on' + aEventName]) return;", "", "\t\taReq.addEventListener(aEventName, function (aEvent) {", "\t\t\tvar responseState = {", "\t\t\t\tresponseText: aReq.responseText,", "\t\t\t\tresponseXML: aReq.responseXML,", "\t\t\t\treadyState: aReq.readyState,", "\t\t\t\tresponseHeaders: null,", "\t\t\t\tstatus: null,", "\t\t\t\tstatusText: null,", "\t\t\t\tfinalUrl: null", "\t\t\t};", "\t\t\tswitch (aEventName) {", "\t\t\t\tcase 'progress':", "\t\t\t\t\tresponseState.lengthComputable = aEvent.lengthComputable;", "\t\t\t\t\tresponseState.loaded = aEvent.loaded;", "\t\t\t\t\tresponseState.total = aEvent.total;", "\t\t\t\t\tbreak;", "\t\t\t\tcase 'error':", "\t\t\t\t\tbreak;", "\t\t\t\tdefault:", "\t\t\t\t\tif (4 !== aReq.readyState) break;", "\t\t\t\t\tresponseState.responseHeaders = aReq.getAllResponseHeaders();", "\t\t\t\t\tresponseState.status = aReq.status;", "\t\t\t\t\tresponseState.statusText = aReq.statusText;", "\t\t\t\t\tbreak;", "\t\t\t}", "\t\t\taOpts['on' + aEventName](responseState);", "\t\t});", "\t}", "", "\tthis.GM.GM_xmlhttpRequest = function (aOpts) {", "\t\t//There is no point in enforcing the @connect metaTag since", "\t\t//you can construct you own XHR without the API anyway", "", "\t\tvar req = new XMLHttpRequest();", "", "\t\tsetupRequestEvent(aOpts, req, 'abort');", "\t\tsetupRequestEvent(aOpts, req, 'error');", "\t\tsetupRequestEvent(aOpts, req, 'load');", "\t\tsetupRequestEvent(aOpts, req, 'progress');", "\t\tsetupRequestEvent(aOpts, req, 'readystatechange');", "", "\t\treq.open(aOpts.method, aOpts.url, !aOpts.synchronous,", "\t\t\taOpts.user || '', aOpts.password || '');", "\t\tif (aOpts.overrideMimeType) {", "\t\t\treq.overrideMimeType(aOpts.overrideMimeType);", "\t\t}", "\t\tif (aOpts.headers) {", "\t\t\tfor (let prop in aOpts.headers) {", "\t\t\t\tif (Object.prototype.hasOwnProperty.call(aOpts.headers, prop)) {", "\t\t\t\t\treq.setRequestHeader(prop, aOpts.headers[prop]);", "\t\t\t\t}", "\t\t\t}", "\t\t}", "\t\tvar body = aOpts.data ? aOpts.data : null;", "\t\tif (aOpts.binary) {", "\t\t\treturn req.sendAsBinary(body);", "\t\t} else {", "\t\t\treturn req.send(body);", "\t\t}", "\t}", "", "\t/**", "\t * Adds a change listener to the storage and returns the listener ID. ", "\t *\t\t'name' is the name of the observed variable. The 'remote' argument", "\t *\t\tof the callback function shows whether this value was modified ", "\t *\t\tfrom the instance of another tab (true) or within this script", "\t *\t\tinstance (false). Therefore this functionality can be used by", "\t *\t\tscripts of different browser tabs to communicate with each other.", "\t * ", "\t * @param {string} name - The name of the observed variable", "\t * @param {function} callback - A callback in which the first argument is", "\t *\t\tthe name of the observed, variable, the second one is the old value,", "\t *\t\tthe third one is the new value and the fourth one is a boolean that", "\t *\t\tindicates whether the change was from a remote tab", "\t * @returns {number} The id of the listener, used for removing it", "\t */", "\tthis.GM.GM_addValueChangeListener = function (name, callback) {", "\t\tstorageListenersGM[++storageIndexGM] = {", "\t\t\tkey: name,", "\t\t\tcallback: callback,", "\t\t\tindex: storageIndexGM", "\t\t};", "\t\treturn storageIndexGM;", "\t}", "", "\t/**", "\t * Removes a change listener by its ID.", "\t * ", "\t * @param {number} listenerId - The id of the listener", "\t */", "\tthis.GM.GM_removeValueChangeListener = function (listenerId) {", "\t\tdelete storageListenersGM[listenerId];", "\t}", "", "\tthis.GM.GM_download = function (detailsOrUrl, name) {", "\t\tvar details = {};", "\t\tif (typeof detailsOrUrl === 'string') {", "\t\t\tdetails.url = detailsOrUrl;", "\t\t\tdetails.name = name;", "\t\t} else {", "\t\t\tdetails = detailsOrUrl;", "\t\t}", "", "\t\tvar options = {", "\t\t\turl: details.url,", "\t\t\tfileName: details.name,", "\t\t\tsaveAs: details.saveAs,", "\t\t\theaders: details.headers", "\t\t};", "\t\tvar request = chromeSpecialRequest('downloads.download', 'GM_download').args(options).fn(function(result) {", "\t\t\tvar downloadId = result.APIArgs[0];", "\t\t\tif (downloadId === undefined) {", "\t\t\t\tisFn(details.onerror)({", "\t\t\t\t\terror: 'not_succeeded',", "\t\t\t\t\tdetails: 'request didn\\'t complete'", "\t\t\t\t});", "\t\t\t} else {", "\t\t\t\tisFn(details.onload)();", "\t\t\t}", "\t\t});", "\t\trequest.onError = function(errorMessage) {", "\t\t\tisFn(details.onerror)({", "\t\t\t\terror: 'not_permitted',", "\t\t\t\tdetails: errorMessage.error", "\t\t\t});", "\t\t}", "\t\trequest.send();", "\t}", "", "\t/**", "\t * I have no idea what this is supposed to do from the documentation:", "\t * https://tampermonkey.net/documentation.php#GM_saveTab", "\t * You can use the comms API instead of this", "\t */", "\tthis.GM.GM_getTab = this.GM.GM_getTabs = function (cb) { cb(); }", "\tthis.GM.GM_saveTab = emptyFn;", "", "\t/*", "\t * The unsafeWindow object provides full access to the pages javascript functions and variables.", "\t */", "\tthis.GM.unsafeWindow = window;", "", "\t/**", "\t * Adds a listener for the notification with ID notificationId", "\t * @param {string} notificationId - The id of te notification to listen for", "\t * @param {function} onclick - The onclick handler for the notification", "\t * @param {function} ondone - The onclose handler for the notification", "\t */", "\tfunction addNotificationListener(notificationId, onclick, ondone) {", "\t\tsendMessage({", "\t\t\tid: id,", "\t\t\ttype: 'addNotificationListener',", "\t\t\tdata: {", "\t\t\t\tnotificationId: notificationId,", "\t\t\t\tonClick: onclick,", "\t\t\t\tonDone: ondone,", "\t\t\t\tid: id,", "\t\t\t\ttabId: _this.tabId", "\t\t\t},", "\t\t\ttabId: _this.tabId", "\t\t});", "\t}", "", "\t/**", "\t * Shows a HTML5 Desktop notification and/or highlight the current tab.", "\t * ", "\t * @param {string} text - The message of the notification", "\t * @param {string} title - The title of the notification", "\t * @param {string} image - A url to the image to use for the notification", "\t * @param {function} onclick - A function to run on clicking the notification", "\t */", "\tthis.GM.GM_notification = function (text, title, image, onclick) {", "\t\tvar details;", "\t\tif (typeof text === 'object' && text) {", "\t\t\tdetails = {", "\t\t\t\tmessage: text.text,", "\t\t\t\ttitle: text.title,", "\t\t\t\ticonUrl: text.imageUrl,", "\t\t\t\tisClickable: !!text.onclick,", "\t\t\t\tonclick: text.onclick", "\t\t\t};", "\t\t\tdetails.ondone = title || text.ondone;", "\t\t} else {", "\t\t\tdetails = {", "\t\t\t\tmessage: text,", "\t\t\t\ttitle: title,", "\t\t\t\ticonUrl: image,", "\t\t\t\tisClickable: !!onclick,", "\t\t\t\tonclick: onclick", "\t\t\t}", "\t\t}", "\t\tdetails.type = 'basic';", "\t\tdetails.iconUrl = details.iconUrl || chrome.runtime.getURl('icon-large.png');", "\t\tonclick = details.onclick && createCallbackFunction(details.onclick, new Error);", "\t\tvar ondone = details.ondone && createCallbackFunction(details.ondone, new Error);", "\t\tdelete details.onclick;", "\t\tdelete details.ondone;", "", "\t\tvar request = chromeSpecialRequest('notifications.create', 'GM_notification').args(details).fn(function(notificationId) {", "\t\t\taddNotificationListener(notificationId, onclick, ondone);", "\t\t});", "\t\trequest.onError = function(errorMessage) {", "\t\t\tconsole.warn(errorMessage);", "\t\t}", "\t\trequest.send();", "\t}", "", "\t//This seems to be deprecated from the tampermonkey documentation page, removed somewhere between january 1st 2016", "\t//\tand january 24th 2016 waiting for any update", "\t/*", "\t * Install a userscript to Custom Right-Click Menu. The callback ", "\t * gets an object like \"{ found: true, installed: true }\" that", "\t * shows whether the script was found and the user installed it.", "\t * ", "\t * @param {string} url - The url of the userscript", "\t * @param {function} callback - The function to call when the script", "\t *\t\tis installed or not", "\t */", "\tthis.GM.GM_installScript = emptyFn; /* function (url, callback) {", "\t\t//Update if re-activated, may be outdated", "\t\tsendMessage({", "\t\t\tid: id,", "\t\t\ttype: 'installScriptMessage',", "\t\t\tdata: {", "\t\t\t\turl: url,", "\t\t\t\tcallback: callback && createCallbackFunction(callback, new Error),", "\t\t\t\tid: id,", "\t\t\t\ttabId: _this.tabId", "\t\t\t},", "\t\t\ttabId: _this.tabId", "\t\t});", "\t}*/", "", "\tvar greaseMonkeyAPIs = this.GM;", "\tfor (var gmKey in greaseMonkeyAPIs) {", "\t\tif (greaseMonkeyAPIs.hasOwnProperty(gmKey)) {", "\t\t\twindow[gmKey] = greaseMonkeyAPIs[gmKey];", "\t\t}", "\t}", "", "\t//#endregion", "", "\treturn this;", "}"]);
}());